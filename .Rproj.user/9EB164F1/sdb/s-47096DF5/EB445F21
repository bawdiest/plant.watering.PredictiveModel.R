{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Blog\"\nauthor: \"mikmak\"\ndate: \"10/3/2016\"\noutput: html_document\n---\n\n\n```{r con.iRig, echo=FALSE}\nlibrary(\"RMySQL\");\n\n# Create DB Connection ----------------------------------------------------\n\ncon.iRig <- dbConnect(MySQL(),\n                 user = \"read\", \n                 host = \"mikmak.cc\",\n                 password = \"809913\", \n                 db = \"iRig\");\n\nsource('gradientDescentMulti.R')\n\nlibrary('lubridate')\n```\n\n# Mit BigData und AI die Pflanzen bewässern\n## Idee\n## Warum BigData und AI und nicht handelsübliches Steuergerät\n\nEinige würden sich fragen, warum musste ich so komplizierte Anlage bauen und nicht einfach eine handelsübliches Gerät kaufen, der mit einem Feuchtigkeitssensor ausgestattet ist. Hier sind einige Argumente:\n\n- eine sensorgesteuerte Anlage hat meistens keine Internet Anbindung. D.h. wenn ich längere Zeit weg bin und es passiert etwas Unvorgesehnbares, kann ich nicht wissen ob die Anlage noch mit Strom versorgt wird (meine Anlage ist an eine Batterie angeschlossen welche von einem Solar Pannel aufgeladen wird), ob der Feuchtigkeitssensor noch richtig positioniert ist und nicht vom Wind umgeworfen wurde und so falsche Daten an die Steuereinheit sendet. (Es ist mir früher schon passiert).\n\n- Handelsübliche Anlagen sind so programmiert, dass diese zu einem bestimmten Zeitpunkt die Sensortwerte auswerten und entscheiden ob die Pumpe gestartet werden soll oder nicht. Z.B. um 17 Uhr meldet der Sensor, dass die Erde trocken ist und es Wasser braucht. Um 17:05 fängt es zu regnen an. So hat die Anlage umsonst das Wasser und Strom verbraucht.\n\n- Skalleneffekte. Eine an die Cloud angeschlossene Anlage benötigt keinen hochqualitativen (und teueren) Sensor. Beim Bau jeder weieter Anlage sinken die Hardware- und somit die Gesamtkosten.\n\n## Lösung im Detail\n\n### Algorithm\n\nEs gibt grundsätzlich zwei Arten von Algorythmen: \n\n- Überwachtes Lernen: hier verwendet man historische Daten um den Rechner zu \"trainieren\" anhand der Input Daten den richtigen Output zu berechnen. z.B. Regressionsanalysen, Neueronale Netze\n\n- Unüberwachtes Lernen: hier lässt man den Rechner die Daten analysieren und gewisse gesetzesmässigkeiten oder Muster zu erkennen. Beispiele sind: Korrelationsanalyse, Clustering. \nFür mein Vorhaben eignen sich die Algorithmen für überwachtes Lernen am Besten. Dabei habe ich dem Tipp eines Stanford Professors gefolgt und habe mit dem einfachsten von Allen begonnen, mit der linearer Regression.\n\n### Lineare Regression\nAlle Algorithmen vom Typ Überwachtes Lernen kann man in Form einer mathematischer Funktion $y = f(X)$ darstellen, wo X eine oder mehrere Input Variablen sind und y ist die sogenannte Target Variable, also der Wert, den wir voraussagen möchten.\n\nDie mathematische Funktion für die lineare Regression sieht so aus:\n\n$$y = \\sum_{i=1}^n (X_i*\\Theta_i)$$\n\nAuch hier steht X für Input Variablen, in meinem Fall sind es: Höchsttemperatur in C in den letzten 24 Stunden, durchschnittlicher Luftdruck in den letzten 24 Stunden usw. y ist die Wassermenge in ml, die eine Pflanze aktuell benötigt. Um y zu berechnen, muss man die Input Parameter X mit den Modell Parametern $\\theta$ multiplizieren und die Resultate aufsummieren.\n\nTönt einfach, ist es auch, mann muss nur passende Parameter $\\theta$ finden. Man nennt es das Modell trainieren. Dazu verwende ich die \"Methode der kleinsten Quadrate\".\n\n1. Dabei vergibt man allen $\\theta$ Parametern einen Initialwert (i.d.R. 0.1) und \n2. man berechnet den Zielparameter $y$ für die historischen Daten. Die Summe der Differenzen zwischen dem errechneten Wert $y_{ber}$ und dem wahren historischen Wert $y_{wahr}$ im Quadrat $\\sum (\\sqrt[2]{(y_{ber} - y_{wahr})^{2}})$ (deswegen Methode der kleinsten Quadrate) ist der korrektur Faktor. \n3. Danach korrigiert man die Parameter $\\theta$ um den Korrektur Faktor. Damit nicht alle Thetas um den selben Wert korrigiert werden, multipliziert man den Korrekturfaktor mit dem jeweiligen Wert $x$. Anschliessend\n4. wiederholt man die Schritte 1-3 x-fach bis der Korrekturfaktor sich nicht mehr wesentlich ändert. In meinem Fall haben 300 Iterationen gereicht.\n\nOK, es ist doch eine zwar richtige, aber doch vereinfachte Erklärung der Methode der kleinsten Quadrate. Wer mehr wissen möchte, empfehle ich den Wikipedia Artikel.\n\nViele Programmiersprachen der 4. Generation (4GL) entwickelt für die statistische Datenverarbeitung wie R, MATLAB, SPSS usw. bieten die Funktionen zur optimierung der linearen Regressionen bereits in der Standardauslieferung.\n\nIn R verwendet man dazu die Funktion $lm()$\n```{r echo=TRUE, eval=FALSE}\nlm(y ~ x + 1)\n```\n### Daten\n\nGemäss einer Studie von Stanford University sind die Trainings Daten wichtiger, als die Wahl des Algorythumus.\n\nDie Daten kann man entweder selber sammeln, kaufen oder die Daten der öffentlichen Insitutionen verwenden (Stichwort \"Open Data\").\n\nFür meinen Fall verwende ich \n- öffentliche Meteo Daten von der MeteoSuisse auf http://www1.ncdc.noaa.gov/pub/data/noaa/ und \n- den von mir gesammelten Bewässerungslog (wie lange ich an welchem Tag die Pflanzen mit der Gardena Anlage bewässert habe)\n\nBewässerungslog ist also die Variable $y$\n\n```{r echo=TRUE}\nsql <- paste('SELECT MsgID, msgv1, TmStp FROM sysLog WHERE msgID = \"109\" AND sysID = \"79cf6c22-dcc6-11e5-8e77-00113217113f\"')\nquery <- dbSendQuery(con.iRig, statement = sql);\ne_pumpLog <- fetch(query)\ndbDisconnect(con.iRig)\n```\n\n```{r echo=TRUE}\ne_pumpLog[3] <- as.POSIXct(e_pumpLog[,3] , origin=\"1970-01-01\")\nt_pumpLog <- e_pumpLog[order(e_pumpLog$TmStp),]\n\nt_pumpLog <- cbind(t_pumpLog, round(t_pumpLog$TmStp, units = \"hours\"))\nnames(t_pumpLog)[ncol(t_pumpLog)] <- \"TimeStpRnd\"\n\nt_pumpLog <- cbind(t_pumpLog, as.Date(t_pumpLog$TimeStpRnd))\nnames(t_pumpLog)[ncol(t_pumpLog)] <- \"DateRnd\"\n\nt_pumpLog <- aggregate(as.integer(t_pumpLog$msgv1), by=list(DateRnd = t_pumpLog$DateRnd), FUN=sum)\nt_pumpLog <- cbind(t_pumpLog, paste(t_pumpLog$DateRnd, \"19:00:00\", sep = \" \"))\nnames(t_pumpLog)[ncol(t_pumpLog)] <- \"TimeStpRnd\"\nt_pumpLog$TimeStpRnd <- parse_date_time(t_pumpLog$TimeStpRnd, c('ymd HMS'))\n\np_pumpLog <- t_pumpLog\n\nplot(p_pumpLog[, c(\"TimeStpRnd\", \"x\")], type = \"h\", col = \"darkblue\")\n```\n\n#### Wetterdaten einlesen und verarbeiten\n```{r echo=TRUE}\ne_weatherData2014 <- read.csv(\"~/CloudStation/private/myProjects/plant.watering.PredictiveModel.R/data/shopdwhdata_2YH_WAE.csv\", sep=\";\", stringsAsFactors=FALSE)\ne_weatherData2016 <- read.csv(\"~/CloudStation/private/myProjects/plant.watering.PredictiveModel.R/data/shopdwhdata_0YH_WAE.csv\", sep=\";\", stringsAsFactors=FALSE)\n\nt_weatherData <- rbind(e_weatherData2014, e_weatherData2016)\nt_weatherData <- cbind(t_weatherData, paste(t_weatherData$date, t_weatherData$time, sep = \" \"))\nnames(t_weatherData)[ncol(t_weatherData)] <- \"TimeStp\"\n\nt_weatherData$TimeStp <- parse_date_time(t_weatherData$TimeStp, c('dmy HM'))\n\np_weatherData <- t_weatherData\nplot(p_weatherData[, c(\"TimeStp\", \"tre200bx\")], type = \"l\", col=\"red\")\n\n```\n\n#### Datenset vorbereiten\n* Input\n    * Wetter vor 24 Stunden\n    * Wetter vor 48 Stunden\n    * Bewesserungstageszeit (Abend/Morgen, Nacht, Tag)\n    * Wetterveränderung seit 24 Stunden (Temperatur, Luftdruck, Niederschlagsmenge)\n* Output\n    * Wasserkonsum in den nächsten 24 Stunden\n  \n```{r echo=TRUE}\nt_dataSet <- p_pumpLog\na_weatherData <- cbind(p_weatherData, p_weatherData$TimeStp - hours(3))\nnames(a_weatherData)[ncol(a_weatherData)] <- \"TimeStp-24\"\na_weatherData <- cbind(a_weatherData, p_weatherData$TimeStp - hours(6))\nnames(a_weatherData)[ncol(a_weatherData)] <- \"TimeStp-27\"\na_weatherData <- cbind(a_weatherData, p_weatherData$TimeStp - hours(12))\nnames(a_weatherData)[ncol(a_weatherData)] <- \"TimeStp-30\"\na_weatherData <- cbind(a_weatherData, p_weatherData$TimeStp - hours(18))\nnames(a_weatherData)[ncol(a_weatherData)] <- \"TimeStp-36\"\na_weatherData <- cbind(a_weatherData, p_weatherData$TimeStp - hours(24))\nnames(a_weatherData)[ncol(a_weatherData)] <- \"TimeStp-42\"\n\nt_dataSet <- merge(t_dataSet, a_weatherData, by.y = \"TimeStp-24\", by.x = \"TimeStpRnd\", suffixes = c(\".m\",\".24\"))\nt_dataSet <- merge(t_dataSet, a_weatherData, by.y = \"TimeStp-27\", by.x = \"TimeStpRnd\", suffixes = c(\".24\",\".27\"))\nt_dataSet <- merge(t_dataSet, a_weatherData, by.y = \"TimeStp-30\", by.x = \"TimeStpRnd\", suffixes = c(\".27\",\".30\"))\nt_dataSet <- merge(t_dataSet, a_weatherData, by.y = \"TimeStp-36\", by.x = \"TimeStpRnd\", suffixes = c(\".30\",\".36\"))\nt_dataSet <- merge(t_dataSet, a_weatherData, by.y = \"TimeStp-42\", by.x = \"TimeStpRnd\", suffixes = c(\".36\",\".42\"))\n\n# Filter relevant columns\nt_dataSet <- t_dataSet[, c(\"TimeStpRnd\", \"x\"\n                       , \"tre200b0.24\", \"tre200bn.24\", \"tre200bx.24\", \"ure200b0.24\", \"rre150b0.24\", \"sre000b0.24\", \"gre000b0.24\",  \"fu3010b1.24\", \"prestab0.24\"\n                       , \"tre200b0.27\", \"tre200bn.27\", \"tre200bx.27\", \"ure200b0.27\", \"rre150b0.27\", \"sre000b0.27\", \"gre000b0.27\",  \"fu3010b1.27\", \"prestab0.27\"\n                       , \"tre200b0.30\", \"tre200bn.30\", \"tre200bx.30\", \"ure200b0.30\", \"rre150b0.30\", \"sre000b0.30\", \"gre000b0.30\",  \"fu3010b1.30\", \"prestab0.30\"\n                       , \"tre200b0.36\", \"tre200bn.36\", \"tre200bx.36\", \"ure200b0.36\", \"rre150b0.36\", \"sre000b0.36\", \"gre000b0.36\",  \"fu3010b1.36\", \"prestab0.36\"\n                       )]\n\nt_dataSet <- t_dataSet\nt_dataSet <- t_dataSet[, !(names(t_dataSet) %in% c(\"TimeStpRnd\"))]\na_dataSet <- as.data.frame(t_dataSet)\n\ny <- a_dataSet$x\nx <- a_dataSet[, !(names(a_dataSet) %in% c(\"TimeStpRnd\", \"x\"))]\n\nx <- data.matrix(x)\nx[is.na(x)] <- 0\n\n  X <- normalizeMatrix(x);\n  y <- normalizeVector(y);\nX[is.na(X)] <- 0\nmodel <- lm(y ~ X + 1)\n\n#model$coefficients[is.na(model$coefficients)] <- 0\n#yP <- cbind(1,x) %*% as.vector(data.matrix((model$coefficients)))\n#yP <- predict(model, a_dataSet[, !(names(a_dataSet) %in% c(\"TimeStpRnd\", \"x\"))])\n\n#View(cbind(t_dataSet$x, yP, t_dataSet$x - yP ))\n\n#View(sum((t_dataSet$x - yP)^2))\n\nView(cbind(model$residuals, model$fitted.values))\nplot(model)\n\n#model <- trainLinearModell(x, as.vector(y))\n  \n  params = list(); \n  \n  params$xMin <- attributes(X)$xMin;\n  params$xMax <- attributes(X)$xMax;\n  params$xFactor <- attributes(X)$xFactor;\n  \n  params$yMin <- attributes(y)$normalizeMin;\n  params$yMax <- attributes(y)$normalizeMax;\n  params$yFactor <- attributes(y)$yFactor;\n  \n  gD <- gradientDescentMulti(X = X, y = y, alpha = 0.01, num_iters = 100);\n  theta <- gD$theta;\n  \n#  plot(gD$cost, xlab=\"Iteration\", ylab=\"Error\");\n  theta <- replace(theta, is.na(theta), 0)\n  \n  t <- X %*% theta\n  t <- t / params$yFactor\n  t <- t + params$yMin\n  \n  View(cbind(t,a_dataSet$x,a_dataSet$x-t))\n  \n  params$theta <- theta\n```\n",
    "created" : 1475496781764.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "391716663",
    "id" : "EB445F21",
    "lastKnownWriteTime" : 1479829218,
    "last_content_update" : 1479829218330,
    "path" : "~/CloudStation/private/myProjects/plant.watering.PredictiveModel.R/ict.blog.Rmd",
    "project_path" : "ict.blog.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}